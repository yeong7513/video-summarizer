import json
import pytest
from unittest.mock import patch, MagicMock

import app
from app import extract_video_id, truncate_text

# Тесты для функции extract_video_id
@pytest.mark.parametrize("url,expected", [
    ("https://www.youtube.com/watch?v=dQw4w9WgXcQ", "dQw4w9WgXcQ"),
    ("https://youtu.be/dQw4w9WgXcQ", "dQw4w9WgXcQ"),
    ("https://www.youtube.com/embed/dQw4w9WgXcQ", "dQw4w9WgXcQ"),
    ("https://www.youtube.com/shorts/dQw4w9WgXcQ", "dQw4w9WgXcQ"),
    ("https://www.youtube.com/watch?v=invalid", None)
])
def test_extract_video_id(url, expected):
    video_id = extract_video_id(url)
    assert video_id == expected

# Тест для truncate_text (предполагается, что функция корректно обрезает текст)
def test_truncate_text():
    # Здесь задаем max_tokens = 5 для теста
    sample_text = "This is a test text to check token truncation."
    truncated = truncate_text(sample_text, 5)
    tokens = app.tokenizer.encode(truncated)
    assert len(tokens) <= 5

# Тестирование функции get_transcript при успешном получении субтитров
@patch("app.YouTubeTranscriptApi.get_transcript")
def test_get_transcript_success(mock_get_transcript):
    # Настройка мока для успешного получения субтитров
    transcript_data = [
        {"text": "Hello"},
        {"text": "World"}
    ]
    mock_get_transcript.return_value = transcript_data

    transcript = app.get_transcript("dummy_video_id")
    # Ожидаем, что субтитры будут объединены в строку "Hello World"
    assert transcript == "Hello World"

# Тестирование функции get_transcript при отсутствии субтитров и использовании автогенерированных
@patch("app.YouTubeTranscriptApi.list_transcripts")
@patch("app.YouTubeTranscriptApi.get_transcript", side_effect=app.TranscriptsDisabled("disabled"))
def test_get_transcript_autogenerated(mock_get_transcript, mock_list_transcripts):
    # Настройка мока для списка транскриптов
    auto_sub = MagicMock()
    auto_sub.fetch.return_value = [MagicMock(text="Auto"), MagicMock(text="generated")]
    transcript_list = MagicMock()
    transcript_list.find_generated_transcript.return_value = auto_sub
    mock_list_transcripts.return_value = transcript_list

    transcript = app.get_transcript("dummy_video_id")
    assert transcript == "Auto generated"

# Тестирование функции summarize_with_deepseek при успешном ответе от API
@patch("app.client.chat.completions.create")
def test_summarize_with_deepseek_success(mock_create):
    # Создаем фиктивный ответ от Deepseek API
    fake_response = MagicMock()
    fake_message = MagicMock()
    fake_message.content = "Summary bullet points."
    fake_response.choices = [MagicMock(message=fake_message)]
    mock_create.return_value = fake_response

    # Пример входного текста
    input_text = "This is a test transcript." * 10
    summary = app.summarize_with_deepseek(input_text)
    assert "Summary" in summary

# Тестирование конечной точки Flask /summarize
@patch("app.extract_video_id")
@patch("app.get_transcript")
@patch("app.summarize_with_deepseek")
def test_summarize_endpoint(mock_summarize_with_deepseek, mock_get_transcript, mock_extract_video_id):
    # Настройка моков для основных функций
    mock_extract_video_id.return_value = "dQw4w9WgXcQ"
    mock_get_transcript.return_value = "Test transcript"
    mock_summarize_with_deepseek.return_value = "Test summary"

    with app.app.test_client() as client:
        # Отправляем корректный POST запрос
        response = client.post(
            "/summarize",
            data=json.dumps({"url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ"}),
            content_type="application/json"
        )
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data["summary"] == "Test summary"
        assert data["video_id"] == "dQw4w9WgXcQ"

# Тест для проверки ошибки при отсутствии URL в запросе
def test_summarize_endpoint_missing_url():
    with app.app.test_client() as client:
        response = client.post(
            "/summarize",
            data=json.dumps({}),
            content_type="application/json"
        )
        assert response.status_code == 400
        data = json.loads(response.data)
        assert "error" in data
        